\section{A. Агроном-любитель}
\textit{Пояснение к примененному алгоритму:} \par
Так как память позволяет нам, я могу сразу считать весь массив чисел, и дальше работать с ним.
Далее я выполняю проверку, что чисел не 0, выбираю минимальные границы в виде первого элемента, и пробегаюсь по массиву считанных чисел.
Как только встречаю три подряд одинаковых, сравниваю расстояние между крайними из них с имеющимися у меня максимальными границами на данный момент и выбираю максимальную из них.
После цикла сравниваю ещё раз расстояние между имеющимися у меня максимальными границами и между ближайшим к концу массива элементом, не входящим в число трёх одинаковых элементов и концом массива.
На случай, если вся строка состоит из элементов, не повторяющихся более двух раз подряд, или если максимальное искомое расстояние ограничивается справа последним элементом массива.
Таким образом, мы за один проход по массиву выясняем максимально отдалённые друг от друга элементы, среди которых нет повторяющихся подряд более двух раз, а так же рассмиотрены все краевые случаи.
\tiny
\begin{verbatim}
#include <iostream>
#include <vector>

using namespace std;

int main() {
  int count_flowers;
  cin >> count_flowers;
  vector<int> gryadka(count_flowers);
  for (int i = 0; i < count_flowers; i++) {
    cin >> gryadka[i];
  }
  if (count_flowers == 0) {
    cout << "0 0" << endl;
    return 0;
  }
  int first_iter = 0;
  int answer1 = 1;
  int answer2 = 1;
  for (int i = 0; i < gryadka.size(); i++) {
    if (gryadka[i] == gryadka[i - 1] && gryadka[i] == gryadka[i - 2]) {
      if (answer2 - answer1 < i - first_iter - 1) {
        answer1 = first_iter + 1;
        answer2 = i;
      }
      first_iter = i - 1;
    }
  }
  if (answer2 - answer1 + 1 < gryadka.size() - first_iter) {
    answer1 = first_iter + 1;
    answer2 = gryadka.size();
  }

  cout << answer1 << " " << answer2 << endl;
}
\end{verbatim}
\normalsize
\BgThispage
\newpage

\section{B. Зоопарк Глеба}
\textit{Пояснение к примененному алгоритму:} \par
Читаем заданную строку, создаём несколько массивов:
\begin{itemize}
    \item массив индексов, куда будем класть на место большой буквы индекс маленькой, ей соответствующей
    \item стек встречающихся больших букв
    \item стек, содержащий их индексы в исходной строке
    \item стек встречающихся маленьких букв
    \item стек, содержащий их порядковый номер среди маленьких букв
    \item общий стек для проверки, что между соответствующими друг другу маленькой и большой буквой не было других незакрытых пар.
\end{itemize}
Далее мы проходим по строке, и, если встречаем букву, проверяем, лежит ли на вершине стеков соответствующая буква:
\begin{itemize}
    \item Если да, то "закрываем пару" - достаём нужную нам букву с вершин, а на порядковое место заглавной буквы кладём номер маленькой.
    \item Если на вершине одного из стека лежит не соответствующая буква, значит, пару закрыть не можем, и отправляем текущую букву на вершину соответствующего ей стека + вершину общего стека, а также записываем её порядковый номер в строке или номер по счёту среди маленьких на вершину соответствующего стека.
\end{itemize}
Таким образом, после прохода по всей строке, мы имеем :
\begin{itemize}
    \item[\ding{51}] массив чисел, каждое ненулевое число которого находится по индексу "закрытой" заглавной буквы и содержит номер по счёту маленькой буквы, ей соответствующей.
    \item[\ding{51}] пустой стек маленьких чисел (если все пары можно "закрыть")
    \item[\ding{43}] пуст ли стек заглавных букв нам не важно, ибо наша задача поймать животных, а ловушки могут оставаться
    \item[\ding{43}] ровно как и общий стек может быть не пуст (если стек животных пуст, в нём могут содержаться ловушки без пар)
    \item[\ding{43}] пара закрывается только в случае, если между ними ничего нет, или есть пары, закрывающиеся друг с другом.
\end{itemize}
\BgThispage
\newpage
\tiny
\begin{verbatim}
#include <iostream>
#include <vector>

using namespace std;

int main() {
  vector<char> line;
  string str;
  getline(cin, str);
  if (str.size() == 0) {
    cout << "Impossible" << endl;
    return 0;
  }
  for (char i : str) {
    line.push_back(i);
  }
  vector<size_t> indexes(line.size());
  size_t lower_literal_count = 0;
  vector<char> upper_literals;
  vector<size_t> upper_literals_indexes;
  vector<char> lower_literals;
  vector<size_t> lower_literals_counts;
  vector<char> common_stack;
  for (size_t i = 0; i < line.size(); i++) {
    if (islower(line[i])) {
      lower_literal_count++;
      if (!upper_literals.empty() &&
          tolower(upper_literals.back()) == line[i] &&
          upper_literals.back() == common_stack.back()) {
        indexes[upper_literals_indexes.back()] = lower_literal_count;
        upper_literals_indexes.pop_back();
        upper_literals.pop_back();
        common_stack.pop_back();
      }
      else {
        lower_literals_counts.push_back(lower_literal_count);
        lower_literals.push_back(line[i]);
        common_stack.push_back(line[i]);
      }
    }
    else {
      if (!lower_literals.empty() &&
          tolower(line[i]) == lower_literals.back() &&
          lower_literals.back() == common_stack.back()) {
        lower_literals.pop_back();
        common_stack.pop_back();
        indexes[i] = lower_literals_counts.back();
        lower_literals_counts.pop_back();
      }
      else {
        upper_literals.push_back(line[i]);
        common_stack.push_back(line[i]);
        upper_literals_indexes.push_back(i);
      }
    }
  }
  if (lower_literals.empty()) {
    cout << "Possible" << endl;
    for (size_t index : indexes) {
      if (index != 0)
        cout << index << " ";
    }
    cout << endl;
  } else {
    cout << "Impossible" << endl;
  }
  return 0;
}
\end{verbatim}
\normalsize
\BgThispage
\newpage

\section{C. Конфигурационный файл}
\textit{Пояснение к примененному алгоритму:} \par
Считываем инпут в массив построчно, создаём:
\begin{itemize}
    \item мапу переменная-значение
    \item мапу, сохраняющую переменную и её старое значение при её изменении.
    \item мапу, сохраняющую переменную при её создании (ну, кстати, тут можно было не мап использовать)
    \item стек, содержащий мапы с изменениями (разделены по блокам)
    \item стек, содержащий мапы с созданиями
    \item все мапы неупорядоченные для скорости
\end{itemize}
Далее проходим по порядку по массиву считанных строк. Когда встречаем открытие блока, кидаем текущие мапы изменений и созданий переменных на стек. Когда блок закрывается, возвращаем старые значения переменным из истории изменений, и удаляем из основной мапы переменные, созданные в блоке. После чего достаём со стека историю предыдущего блока и продолжаем её.
Если встречаем строку, отличную от скобок, то парсим её (простой алгоритм ветвления), выводим значение переменной при присваиваинии.
Таким образом, в каждый момент времени мы имеем корректную информацию о значениях переменных, а стек историй действует эффективно, что позволяет проходить Memory Limit.
\BgThispage
\newpage
\tiny
\begin{verbatim}
#include <iostream>
#include <vector>
#include <unordered_map>
#include <stack>

using namespace std;


bool check_var_or_not(string s);

int64_t get_delim_pos(string stroka) {
    for (size_t i = 0; i < stroka.size(); i++) {
        char symbol = stroka.at(i);
        if (symbol == 61) {
            return i;
        }
    }
    return 0;
}

int main() {
    vector<string> text;
    unordered_map<string, string> mymap;
    unordered_map<string, string> history_changes;
    unordered_map<string, string> history_creates;
    stack<unordered_map<string, string>> stack_changes;
    stack<unordered_map<string, string>> stack_creates;
    string line;
    while (cin >> line) {
        text.push_back(line);
    }
    for (string stroka: text) {
        if (stroka == "{") {
            stack_changes.push(std::move(history_changes));
            stack_creates.push(std::move(history_creates));
            history_changes.clear();
            history_creates.clear();
        } else if (stroka == "}") {
            for (pair<string, string> pair: history_changes) {
                mymap[pair.first] = pair.second;
            }
            for (pair <string, string> pair: history_creates) {
                mymap.erase(pair.first);
            }
            history_changes = (std::move(stack_changes.top()));
            stack_changes.pop();
            history_creates = (std::move(stack_creates.top()));
            stack_creates.pop();
        } else {
            int64_t delim_pos = get_delim_pos(stroka);
            string left_value = (stroka.substr(0, delim_pos));
            string right_value = (stroka.substr(delim_pos + 1, stroka.size() - 1));
            auto left_value_pos = mymap.find(left_value);
            auto pos_in_history = history_changes.find(left_value);
            if (left_value_pos != mymap.end() && pos_in_history == history_changes.end())
                history_changes.insert({left_value_pos->first, left_value_pos->second});
            if (left_value_pos == mymap.end()) history_creates.insert({left_value, right_value});
            bool value_is_a_var = check_var_or_not(right_value);
            if (value_is_a_var) {
                auto iter = mymap.find(right_value);
                if (iter == mymap.end()) {
                    mymap[left_value] = "0";
                    cout << "0" << endl;
                } else {
                    mymap[left_value] = iter->second;
                    cout << iter->second << endl;
                }
            } else {
                mymap[left_value] = right_value;
            }
        }
    }
    return 0;
}

bool check_var_or_not(string s) {
    char first_symbol = s.at(0);
    if ((first_symbol == 45) || (first_symbol >= 48 && first_symbol <= 57)) {
        return false;
    }
    return true;
}
\end{verbatim}
\normalsize
\BgThispage
\newpage

\section{D. Профессор Хаос}
\textit{Пояснение к примененному алгоритму:} \par
Просто проходим по описанному алгоритму min(1000, k) раз и выводим ответ.
1000 раз будет достаточно, потому что вместимость $d \leqslant $1000, если a*b-c будет положительным,
то количество бактерий будет увеличиваться минимум на единицу, и за 1000 итераций мы дойдём до максимума,
а если оно хоть раз обратится в 0, то будет всегда равным 0.
\tiny
\begin{verbatim}
#include <iostream>

using namespace std;

int main() {
  int64_t a, result, b, c, d;
  uint64_t k;
  cin >> a >> b >> c >> d >> k;
  result = a;
  for (size_t i = 0; i < 1000 && i < k; i++) {
    a = result;
    result = a * b - c;
    if (result <= 0) {
      result = 0;
      break;
    } else {
      result = min(result, d);
    }
  }
  cout << result << endl;
  return 0;
}
\end{verbatim}
\BgThispage
